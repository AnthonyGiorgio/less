#!/usr/bin/env perl
use strict;
use Getopt::Std;
use IO::Stty;

my $usage =
    "usage: ltview lt-file [error-file]\n" .
    "       error-file is output from \"lesstest -D\"\n";

my $help = <<_EOF_;
\r
Commands:\r
[N]l   Go to (N-th) next lt state.\r
[N]h   Go to (N-th) previous lt state.\r
[N]g   Go to first (or N-th) lt state.\r
[N]G   Go to last (or N-th) lt state.\r
   j   Go to next error file state.\r
   k   Go to previous error file state.\r
   e   Go to lt state corresponding to error file state.\r
   ?   Display help.\r
_EOF_

my $ATTR_BOLD           = (1<<0);
my $ATTR_UNDERLINE      = (1<<1);
my $ATTR_STANDOUT       = (1<<2);
my $ATTR_BLINK          = (1<<3);
my $NULL_COLOR          = 0xFF;

my %opt;

# ---------------------------------------------------------------------
exit (main() ? 0 : 1);

sub main {
    die $usage if not getopts('cr', \%opt);
    my $ltfile = shift @ARGV;
    my $errfile = shift @ARGV;
    die $usage if not defined $ltfile or @ARGV;
    my $lt = parse_ltfile($ltfile);
    return 0 if not $lt;
    my $errf = defined $errfile ? parse_errfile($errfile) : undef;
    run($lt, $errf);
    return 1;
}

# ---------------------------------------------------------------------
sub run {
    my ($lt, $errf) = @_;
    my $states = $lt->{states};
    return if not @$states;
    my $omode = IO::Stty::stty(\*STDIN, '-g');
    IO::Stty::stty(\*STDIN, ('raw','-echo')) unless $opt{r};
    my $sindex = 0;
    my $param = '';
    my @show_expects = ('', 'expect', 'got');
    my $show_expect = 0;
    for (;;) {
        if ($show_expect > 0) {
            my $exp = $show_expects[$show_expect];
            my $prompt = sprintf(" %s%s (%s before %02x) [%d/%d] %s %s", attr_string('so'), $errf->{filename}, $exp, $errf->{fail_char}, $errf->{fail_index}, scalar @$states, attr_string(), $param);
            display($errf->{$exp}, $prompt, $lt);
        } else {
            my $prompt = sprintf(" %s%s [%d/%d]%s %s", attr_string('so'), $lt->{filename}, $sindex, scalar @$states, attr_string(), $param);
            display(${$$states[$sindex]}{img}, $prompt, $lt);
        }
        my $ch = getc();
        $ch = substr($ch,0,1);
        last if $ch eq 'q';
        if ($ch ge '0' and $ch le '9') {
            $param .= $ch;
        } else {
            my $num = $param;
            $num = 0 if $num !~ /^\d+$/ or $num <= 0;
            $param = '';
            if ($ch eq '?') {
                tgoto_bot($lt);
                print $help;
                print "\r\nPress any key to continue. ";
                getc();
            } elsif ($ch eq 'l') {
                $show_expect = 0;
                $num = 1 if $num == 0;
                $sindex = check_sindex($sindex + $num, $states);
            } elsif ($ch eq 'h') {
                $show_expect = 0;
                $num = 1 if $num == 0;
                $sindex = check_sindex($sindex - $num, $states);
            } elsif ($ch eq 'g' or $ch eq 'G' or $ch eq 'e') {
                $show_expect = 0;
                $num = @$states-1 if $ch eq 'G' and $num == 0;
                if ($ch eq 'e') {
                    if (not $errf) {
                        beep();
                    } else {
                        $num = $errf->{fail_index};
                    }
                }
                $sindex = check_sindex($num, $states);
            } elsif ($ch eq 'j') {
                if (not $errf) {
                    beep();
                } else {
                    if (++$show_expect >= @show_expects) { $show_expect = 0; }
                }
            } elsif ($ch eq 'k') {
                if (not $errf) {
                    beep();
                } else {
                    if (--$show_expect < 0) { $show_expect = @show_expects-1; }
                }
            } else {
                beep();
            }
        }
    }
    tgoto_bot($lt);
    IO::Stty::stty(\*STDIN, $omode);
}

# ---------------------------------------------------------------------
sub check_sindex {
    my ($sindex, $states) = @_;
    if ($sindex < 0) { beep(); $sindex = 0; }
    if ($sindex >= @$states) { beep(); $sindex = @$states-1; }
    return $sindex;
}

# ---------------------------------------------------------------------
sub display {
    my ($img, $prompt, $lt) = @_;
    my $x = 0;
    my $y = 0;
    my $cursor_x = 0;
    my $cursor_y = 0;
    my $literal = 0;
    my $curr_attr = 0;
    my $curr_fg_color = -1;
    my $curr_bg_color = -1;

    print "\e[H\e[J";
    for (my $cpos = 0; $cpos < length $img; ) {
        my $ch = substr $img, $cpos++, 1;
        if (not $literal) {
            if ($ch eq '\\') { # escape
                $literal = 1;
                next;
            }
            if ($ch eq '@') { # attr
                $curr_attr = hex substr($img, $cpos, 2);
                $cpos += 2;
                display_attr_color($curr_attr, $curr_fg_color, $curr_bg_color);
                next;
            }
            if ($ch eq '$') { # fg color
                $curr_fg_color = hex substr($img, $cpos, 2);
                $cpos += 2;
                display_attr_color($curr_attr, $curr_fg_color, $curr_bg_color);
                next;
            }
            if ($ch eq '!') { # bg color
                $curr_bg_color = hex substr($img, $cpos, 2);
                $cpos += 2;
                display_attr_color($curr_attr, $curr_fg_color, $curr_bg_color);
                next;
            }
            if ($ch eq '#') { # cursor
                $cursor_x = $x;
                $cursor_y = $y;
                next;
            }
        }
        $literal = 0;
        print $ch if length($ch) > 0;
        if (++$x >= $lt->{columns}) {
            print "\r\n";
            $x = 0;
            ++$y;
        }
    }
    printf "\r\n%s", $prompt;
    tgoto($cursor_x, $cursor_y);
}

# ---------------------------------------------------------------------
sub display_attr_color {
    my ($attr, $fg_color, $bg_color) = @_;
    print "\e[m";
    print "\e[${fg_color}m" if ($fg_color != $NULL_COLOR);
    print "\e[${bg_color}m" if ($bg_color != $NULL_COLOR);
    print "\e[4m" if ($attr & $ATTR_UNDERLINE);
    print "\e[1m" if ($attr & $ATTR_BOLD);
    print "\e[5m" if ($attr & $ATTR_BLINK);
    print "\e[7m" if ($attr & $ATTR_STANDOUT);
}

sub attr_string {
    my ($mode) = @_;
    return "\e[m" if not $mode;
    return ($opt{c} ? "\e[106;30m" : "\e[7m") if $mode eq 'so';
    return "";
}
sub tgoto {
    my ($x, $y) = @_;
    printf "\e[%d;%dH", $y+1, $x+1;
}
sub tgoto_bot {
    my ($lt) = @_;
    tgoto(0, $lt->{lines}+2);
}
sub beep {
    print "\7";
}

# ---------------------------------------------------------------------
sub parse_ltfile {
    my ($file) = @_;
    my $fd;
    if (not open $fd, '<', $file) {
        print STDERR "cannot open $file: $!\n";
        return undef;
    }
    my @states;
    my %lt = ( 'filename' => $file, 'states' => \@states );
    my $filetype = '';
    my $linenum = 0;
    while (<$fd>) {
        ++$linenum;
        chomp;
        if ($linenum > 1 and $filetype ne 'lesstest') {
            print STDERR "$file is not an lt file\n";
            return undef;
        }
        my $type = substr $_,0,1;
        next if not defined $type;
        if ($type eq '!') { # file header
            if (/^!([^!]+)!/) { $filetype = $1; }
        } elsif ($type eq 'A') { # less cmd line parameters
        } elsif ($type eq 'E') { # environment variable
            parse_env($_, \%lt);
        } elsif ($type eq 'F') { # text file
            parse_filedesc($_, $fd, \%lt);
        } elsif ($type eq 'Q') { # end of test
            last;
        } elsif ($type eq 'R') { # end of test header; start run
        } elsif ($type eq 'T') { # test header
        } elsif ($type eq '=') { # board image
            parse_img($_, \%lt);
        } elsif ($type eq '+') { # keystroke
            parse_keystroke($_, \%lt);
        } 
    }
    close $fd;
    if (not $lt{lines} or not $lt{columns}) {
        print STDERR "$file: missing geometry\n";
        return undef;
    }
    return \%lt;
}

# ---------------------------------------------------------------------
sub parse_env {
    my ($line, $lt) = @_;
    my ($ename, $evalue) = /^E \s* "(\w*)" \s* "([^"]*)" /x;
    if ($ename eq "COLUMNS") {
        $lt->{columns} = $evalue;
    } elsif ($ename eq "LINES") {
        $lt->{lines} = $evalue;
    }
    return 1;
}

# ---------------------------------------------------------------------
sub parse_filedesc {
    my ($line, $fd, $lt) = @_;
    my ($filename, $filesize) = $line =~ /^F \s* "([^"]*)" \s* (\d+)/x;
    my $filedata;
    my $nread = read $fd, $filedata, $filesize;
    return 0 if not $nread or $nread != $filesize;
    return 1;
}

# ---------------------------------------------------------------------
sub parse_img {
    my ($line, $lt) = @_;
    my $img = substr $line, 1;
    my %state = ( 'img'=>$img );
    my $states = $lt->{states};
    if (@$states) {
        my $last_state = ${$states}[@$states-1];
        if (not $last_state->{img} or not $last_state->{keystroke}) {
            print STDERR "incomplete state image ignored\n";
        }
    }
    push @$states, \%state;
    return 1;
}

# ---------------------------------------------------------------------
sub parse_errfile {
    my ($errfile) = @_;
    my $ef;
    if (not open $ef, '<', $errfile) {
        print STDERR "cannot open $errfile: $!\n";
        return undef;
    }
    my %errf = ( 'filename' => $errfile );
    my $expect;
    my $datalines = 0;
    my $linenum = 0;
    while (<$ef>) {
        ++$linenum;
        chomp;
        if (0) {
        } elsif (/expect:/) {
            $expect = 'expect';
            $datalines = 1;
        } elsif (/got:/) {
            $expect = 'got';
            $datalines = 1;
        } elsif (/^TEST\s+([^\s]+)/) {
            $errf{name} = $1;
        } elsif (/^DIFF\s+([^\s]+) on cmd #(\d+) \(.\s+(\w+)\s*\)/) {
            $errf{fail_index} = $2; # FIXME why not $2-1?
            $errf{fail_char} = hex $3;
            $datalines = 0;
        } elsif (/^FAIL:.*\((\d+) step/) {
            $errf{steps} = $1;
        } elsif (/^ERR /) {
        } elsif (/^RAN /) {
        } else {
            if ($datalines) {
                $errf{$expect} .= $_;
            } else {
                print STDERR "$errfile:$linenum: unexpected data line\n";
            }
        }
    }
    close $ef;
    if (not defined $errf{expect} or not defined $errf{got} or not defined $errf{fail_index}) {
        print STDERR "incomplete error file $errfile ignored\n";
        return undef;
    }
    return \%errf;
}

# ---------------------------------------------------------------------
sub parse_keystroke {
    my ($line, $lt) = @_;
    my ($hex) = $line =~ /^\+ \s* (\w+)/x;
    my $states = $lt->{states};
    return 0 if not @$states;
    ${$$states[@$states-1]}{keystroke} = hex $hex;
    return 1;
}
